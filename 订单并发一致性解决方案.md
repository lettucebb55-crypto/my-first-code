# 订单并发一致性解决方案

## 一、问题分析

### 1.1 并发场景

在旅游平台中，订单并发一致性问题主要出现在以下场景：

1. **库存/余量控制**
   - 路线成团人数限制（如：最多10人，已有8人报名）
   - 酒店房间数量限制
   - 景点门票库存限制

2. **订单创建并发**
   - 多个用户同时预订同一路线/酒店
   - 订单号生成唯一性
   - 订单金额计算准确性

3. **支付并发**
   - 同一订单多次支付
   - 支付状态更新
   - 库存扣减

### 1.2 并发问题示例

**场景1：超卖问题**
```
用户A和用户B同时预订同一路线（剩余2个名额）
- 用户A查询：剩余2个名额 ✓
- 用户B查询：剩余2个名额 ✓
- 用户A创建订单：剩余1个名额
- 用户B创建订单：剩余0个名额
- 结果：实际售出2个，但系统显示剩余0个（正确）
- 但如果剩余1个名额，两个用户都成功下单，就会超卖！
```

**场景2：订单号重复**
```
两个用户同时创建订单
- 用户A生成订单号：BD20241130123456
- 用户B生成订单号：BD20241130123456（时间戳相同，随机数相同）
- 结果：订单号冲突，数据库唯一约束报错
```

**场景3：重复支付**
```
用户对同一订单多次点击支付
- 第一次支付：订单状态 pending → paid
- 第二次支付：订单状态 pending → paid（重复扣款）
```

---

## 二、解决方案

### 2.1 数据库层面解决方案

#### （1）使用数据库事务（Transaction）

```python
from django.db import transaction

@transaction.atomic
def create_order(user, item_id, item_type, quantity, contact_name, contact_phone):
    """创建订单 - 使用事务保证原子性"""
    try:
        # 在事务中执行所有数据库操作
        # 如果任何一步失败，整个事务回滚
        order = Order.objects.create(...)
        OrderDetail.objects.create(...)
        # 更新库存
        update_inventory(item_id, item_type, quantity)
        return order
    except Exception as e:
        # 事务自动回滚
        raise
```

#### （2）使用数据库锁（Select For Update）

**悲观锁**：在查询时锁定记录，其他事务必须等待

```python
from django.db import transaction
from django.db.models import F

@transaction.atomic
def create_order_with_lock(user, route_id, quantity):
    """创建路线订单 - 使用悲观锁"""
    # 使用 select_for_update() 锁定路线记录
    route = Route.objects.select_for_update().get(id=route_id)
    
    # 检查剩余名额
    if route.group_size - route.sales_count < quantity:
        raise ValueError("名额不足")
    
    # 更新销售数量（使用F表达式，数据库层面原子操作）
    Route.objects.filter(id=route_id).update(
        sales_count=F('sales_count') + quantity
    )
    
    # 创建订单
    order = Order.objects.create(...)
    return order
```

#### （3）使用乐观锁（版本号机制）

```python
# 在模型中添加版本号字段
class Route(models.Model):
    # ... 其他字段
    version = models.IntegerField(default=0, verbose_name="版本号")

# 更新时检查版本号
@transaction.atomic
def create_order_optimistic(user, route_id, quantity):
    """创建订单 - 使用乐观锁"""
    max_retries = 3
    for attempt in range(max_retries):
        try:
            route = Route.objects.get(id=route_id)
            old_version = route.version
            
            # 检查名额
            if route.group_size - route.sales_count < quantity:
                raise ValueError("名额不足")
            
            # 更新（同时更新版本号）
            updated = Route.objects.filter(
                id=route_id,
                version=old_version  # 只有版本号匹配才更新
            ).update(
                sales_count=F('sales_count') + quantity,
                version=F('version') + 1
            )
            
            if updated == 0:
                # 版本号不匹配，说明有其他事务修改了，重试
                continue
            
            # 创建订单
            order = Order.objects.create(...)
            return order
            
        except Exception as e:
            if attempt == max_retries - 1:
                raise
            continue
```

### 2.2 应用层面解决方案

#### （1）分布式锁（Redis）

```python
import redis
from django.conf import settings
import time

redis_client = redis.Redis(
    host=settings.REDIS_HOST,
    port=settings.REDIS_PORT,
    db=0
)

def create_order_with_redis_lock(user, route_id, quantity):
    """使用Redis分布式锁创建订单"""
    lock_key = f"order_lock:route:{route_id}"
    lock_timeout = 10  # 锁超时时间（秒）
    
    # 尝试获取锁
    lock_acquired = redis_client.set(
        lock_key, 
        "locked", 
        nx=True,  # 只在键不存在时设置
        ex=lock_timeout  # 设置过期时间
    )
    
    if not lock_acquired:
        raise ValueError("系统繁忙，请稍后重试")
    
    try:
        # 在锁保护下执行订单创建
        route = Route.objects.get(id=route_id)
        if route.group_size - route.sales_count < quantity:
            raise ValueError("名额不足")
        
        Route.objects.filter(id=route_id).update(
            sales_count=F('sales_count') + quantity
        )
        
        order = Order.objects.create(...)
        return order
    finally:
        # 释放锁
        redis_client.delete(lock_key)
```

#### （2）订单号生成唯一性保证

```python
import time
import random
from django.db import transaction
from django.utils.crypto import get_random_string

def generate_unique_order_sn():
    """生成唯一订单号"""
    max_retries = 10
    for _ in range(max_retries):
        # 时间戳 + 随机数
        order_sn = f"BD{timezone.now().strftime('%Y%m%d%H%M%S')}{get_random_string(4, '0123456789')}"
        
        # 检查是否已存在
        if not Order.objects.filter(order_sn=order_sn).exists():
            return order_sn
        
        # 如果存在，等待一小段时间后重试
        time.sleep(0.01)
    
    # 如果10次都重复，使用UUID
    import uuid
    return f"BD{timezone.now().strftime('%Y%m%d')}{uuid.uuid4().hex[:8].upper()}"

@transaction.atomic
def create_order_safe(user, item_id, item_type, quantity, contact_name, contact_phone):
    """安全创建订单"""
    # 生成唯一订单号
    order_sn = generate_unique_order_sn()
    
    # 使用 select_for_update 锁定相关资源
    if item_type == 'route':
        item = Route.objects.select_for_update().get(id=item_id)
        # 检查并更新库存
        if item.group_size - item.sales_count < quantity:
            raise ValueError("名额不足")
        item.sales_count += quantity
        item.save()
    elif item_type == 'hotel':
        # 类似处理酒店房间
        pass
    
    # 创建订单
    order = Order.objects.create(
        order_sn=order_sn,
        user=user,
        total_amount=item.price * quantity,
        status='pending',
        contact_name=contact_name,
        contact_phone=contact_phone
    )
    
    # 创建订单明细
    OrderDetail.objects.create(
        order=order,
        item_type=item_type,
        item_id=item_id,
        item_name=item.name,
        price=item.price,
        quantity=quantity,
        subtotal=item.price * quantity
    )
    
    return order
```

#### （3）防止重复支付

```python
from django.db import transaction
from django.db.models import F

@transaction.atomic
def process_payment(order_sn, user):
    """处理支付 - 防止重复支付"""
    # 使用 select_for_update 锁定订单
    order = Order.objects.select_for_update().get(
        order_sn=order_sn,
        user=user
    )
    
    # 检查订单状态
    if order.status != 'pending':
        raise ValueError(f"订单状态错误，当前状态：{order.get_status_display()}")
    
    # 原子性更新订单状态
    updated = Order.objects.filter(
        order_sn=order_sn,
        status='pending'  # 只有pending状态才能更新
    ).update(
        status='paid',
        paid_at=timezone.now()
    )
    
    if updated == 0:
        raise ValueError("订单状态已变更，支付失败")
    
    return order
```

### 2.3 前端层面解决方案

#### （1）防重复提交

```javascript
// 使用按钮禁用和防抖
let isSubmitting = false;

function submitOrder() {
    if (isSubmitting) {
        return false; // 防止重复提交
    }
    
    isSubmitting = true;
    const submitBtn = document.getElementById('submitBtn');
    submitBtn.disabled = true;
    submitBtn.textContent = '提交中...';
    
    // 提交订单
    fetch('/orders/create/', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            window.location.href = '/orders/payment/' + data.order_sn + '/';
        } else {
            alert(data.message);
            isSubmitting = false;
            submitBtn.disabled = false;
            submitBtn.textContent = '提交订单';
        }
    })
    .catch(error => {
        console.error(error);
        isSubmitting = false;
        submitBtn.disabled = false;
        submitBtn.textContent = '提交订单';
    });
}
```

---

## 三、实际实现方案

### 3.1 改进后的订单创建视图

```python
# apps/orders/views.py

from django.db import transaction
from django.db.models import F
from django.utils import timezone
from django.utils.crypto import get_random_string
import time

class OrderPaymentView(LoginRequiredMixin, View):
    """订单支付视图 - 改进版，支持并发控制"""
    
    def generate_unique_order_sn(self):
        """生成唯一订单号"""
        max_retries = 10
        for _ in range(max_retries):
            order_sn = f"BD{timezone.now().strftime('%Y%m%d%H%M%S')}{get_random_string(4, '0123456789')}"
            if not Order.objects.filter(order_sn=order_sn).exists():
                return order_sn
            time.sleep(0.01)
        
        # 如果还是重复，使用UUID
        import uuid
        return f"BD{timezone.now().strftime('%Y%m%d')}{uuid.uuid4().hex[:8].upper()}"
    
    @transaction.atomic
    def create_order(self, user, item_id, item_type, quantity, contact_name, contact_phone):
        """创建订单 - 使用事务和锁保证一致性"""
        try:
            # 生成唯一订单号
            order_sn = self.generate_unique_order_sn()
            
            # 获取项目信息和价格（使用select_for_update锁定）
            item_name = ''
            price = 0
            
            if item_type == 'scenic':
                # 景点门票通常不需要库存控制
                item = ScenicSpot.objects.get(pk=item_id)
                item_name = item.name
                price = item.ticket_price
                
            elif item_type == 'route':
                # 路线需要控制成团人数，使用悲观锁
                item = Route.objects.select_for_update().get(pk=item_id)
                item_name = item.name
                price = item.price
                
                # 检查剩余名额
                available_slots = item.group_size - item.sales_count
                if available_slots < quantity:
                    raise ValueError(f"名额不足，剩余{available_slots}个名额")
                
                # 原子性更新销售数量
                Route.objects.filter(id=item_id).update(
                    sales_count=F('sales_count') + quantity
                )
                
            elif item_type == 'hotel':
                # 酒店需要控制房间数量
                item = Hotel.objects.select_for_update().get(pk=item_id)
                item_name = item.name
                room_type = RoomType.objects.filter(
                    hotel=item, 
                    is_available=True
                ).order_by('price').first()
                
                if not room_type:
                    raise ValueError("暂无可用房间")
                
                price = room_type.price
                
                # 这里可以添加房间库存控制逻辑
                # 例如：room_type.available_count -= quantity
                
            else:
                raise ValueError("不支持的项目类型")
            
            total_amount = price * quantity
            
            # 创建订单
            order = Order.objects.create(
                order_sn=order_sn,
                user=user,
                total_amount=total_amount,
                status='pending',
                contact_name=contact_name,
                contact_phone=contact_phone
            )
            
            # 创建订单明细
            OrderDetail.objects.create(
                order=order,
                item_type=item_type,
                item_id=item_id,
                item_name=item_name,
                price=price,
                quantity=quantity,
                subtotal=total_amount
            )
            
            return order
            
        except ValueError as e:
            # 业务逻辑错误，直接抛出
            raise
        except Exception as e:
            # 其他错误，记录日志
            import logging
            logger = logging.getLogger(__name__)
            logger.error(f"创建订单失败: {e}")
            raise ValueError("订单创建失败，请稍后重试")
    
    @transaction.atomic
    def handle_payment_success(self, request, order_sn):
        """处理支付成功 - 防止重复支付"""
        try:
            # 使用select_for_update锁定订单
            order = Order.objects.select_for_update().get(
                order_sn=order_sn,
                user=request.user
            )
            
            # 检查订单状态
            if order.status != 'pending':
                # 订单已经不是待支付状态，可能是重复支付
                return HttpResponseRedirect('/users/orders/')
            
            # 原子性更新订单状态（只有pending状态才能更新）
            updated = Order.objects.filter(
                order_sn=order_sn,
                status='pending'
            ).update(
                status='paid',
                paid_at=timezone.now()
            )
            
            if updated == 0:
                # 订单状态已被其他请求修改
                return HttpResponseRedirect('/users/orders/')
            
        except Order.DoesNotExist:
            pass
        
        return HttpResponseRedirect('/users/orders/')
```

### 3.2 在Route模型中添加库存控制

```python
# apps/routes/models.py

class Route(models.Model):
    # ... 现有字段
    group_size = models.PositiveIntegerField(default=10, verbose_name="成团人数")
    sales_count = models.PositiveIntegerField(default=0, verbose_name="已报名人数")
    
    def get_available_slots(self):
        """获取剩余名额"""
        return max(0, self.group_size - self.sales_count)
    
    def is_available(self, quantity=1):
        """检查是否有足够名额"""
        return self.get_available_slots() >= quantity
```

---

## 四、总结

### 4.1 解决方案总结

| 问题 | 解决方案 | 实现方式 |
|------|---------|---------|
| 库存超卖 | 悲观锁 + 事务 | `select_for_update()` + `@transaction.atomic` |
| 订单号重复 | 唯一性检查 + 重试 | 检查数据库 + UUID备用 |
| 重复支付 | 状态检查 + 原子更新 | `filter(status='pending').update()` |
| 并发创建订单 | 数据库锁 | `select_for_update()` |

### 4.2 最佳实践

1. **使用数据库事务**：确保操作的原子性
2. **使用悲观锁**：对于库存等关键资源，使用`select_for_update()`
3. **使用原子更新**：使用`F()`表达式进行数据库层面的原子操作
4. **前端防重复提交**：按钮禁用、防抖处理
5. **错误处理**：完善的异常处理和用户提示
6. **日志记录**：记录关键操作，便于问题排查

### 4.3 性能考虑

- **锁粒度**：尽量缩小锁的范围，减少锁持有时间
- **索引优化**：确保查询字段有索引，提升查询速度
- **连接池**：使用数据库连接池，避免连接耗尽
- **缓存**：对于不经常变化的数据，可以使用缓存

---

**文档版本**：v1.0  
**创建日期**：2024年

